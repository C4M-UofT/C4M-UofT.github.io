import numpy as npimport pylabimport sysfrom skimage import iofrom skimage import colorfrom scipy import ndimagefrom matplotlib import pyplotimport project_helpers as phfrom sklearn.multiclass import OneVsRestClassifierfrom sklearn.svm import SVCfrom sklearn import svmfrom sklearn.preprocessing import LabelBinarizerfrom sklearn.ensemble import RandomForestClassifier############## This tutorial walks through various functions used for the project# and some of the concepts covered in lecture.############### Flag that indicates whether to show images.# When True you will need to close each window after you've looked at the output to continueVIEW = False# Set the path to the data files.data_path = "crchistophenotypes_2016_04_28/CRCHistoPhenotypes_2016_04_28/"##############Basic image I/O###############Load the ground truth labels#Detections are stored as [x,y] and labels are positive for detected nuclei centres#Set VIEW = True and in the resulting plot examine a value in the image array.img, detections, labels = ph.load_data_set(data_path,"img7")pylab.imshow(img)if(VIEW):    pyplot.show()#When you mouse-over a point in the image (a pixel), you will see 5 numbers in the bottom right corner.# E.g. [x = 100, y = 100] [201, 136, 201]; These denote the X,Y location of the pixel (on a cartesian grid),# and the colour in [Red, Green, Blue]. Think of the amount of red paint, green paint, and blue paint you# would need to mix to make a colour. It works a bit differently than paint, but it is a good analogy.#Close the image window to continue.#Images in python are stored [Y,X]. So this is (y=1,x=5)img[1,5]#Display only the red channel - This is the red component of the image. pylab.imshow(img[:,:,0])if(VIEW):    pyplot.show()#Close the image window to continue.#Show the image with detections from the ground truth databasepyplot.imshow(img)pyplot.autoscale(False)#Remember that the ground truth was stored as (x,y). Thankfully plot uses that input order.pyplot.plot(detections[:, 0], detections[:, 1], 'kx')if(VIEW):    pyplot.show()#Close the image window to continue.#################Filtering: Lowest level vision# This section covers how to perform filtering of an image to reduce noise or highlight structures.# Think of sliding your thumb across a wet oil canvas. Filtering can work the same way, smearing all the# nearby pixels colours together. If we do it in the right way, however, it will highlight instead of smear.##################Build a 3x3 averaging filter to smear the image, which can reduce noise. We covered this example in the slides.F = (1 / 9) * np.array([[1, 1, 1],[1, 1, 1],[1, 1, 1]])F#Perform convolution on the red channel only and store the resultimgSmooth = ndimage.convolve(img[:,:,0].astype('float'), F, mode='constant', cval=0.0)#Perform repeated convolution and store the result. What do you think this will do?imgManySmooth = ndimage.convolve(img[:,:,0].astype('float'), F, mode='constant', cval=0.0)for a in range(1,30):    imgManySmooth = ndimage.convolve(imgManySmooth, F, mode='constant', cval=0.0)    pylab.subplot(1, 3, 1)pylab.imshow(img[:, :, 0].astype('float'))pylab.subplot(1, 3, 2)pylab.imshow(imgSmooth)pylab.subplot(1, 3, 3)pylab.imshow(imgManySmooth)if(VIEW):    pyplot.show()#Visually examine the results and then close the image to continue.#We can put the result back into the original image to see what the result looks like in colour.#Note, we've only blurred the red channel, and so we copy it over.imgBlur = imgimgBlur[:,:,0] = imgManySmoothpylab.imshow(imgBlur)if(VIEW):    pyplot.show()################################    #Basic edge detection#################################First make a grayscale copy of the imageimg_gray = color.rgb2gray(img)#Now we build an edge detection filter, that takes the difference between nearby pixels.#It is a numerical estimate of the first derivative (i.e. the slope) of the image along the X-axisFx = np.array([[1, 0, -1]])#We can also calculate the slope along the Y-axisFy = Fx.transpose()#We perform convolution as above, but we use a different boundary condition: 'nearest'.#Nearest wraps the image around on itself, think of rolling a peice of paper into a tube.#We do this to smooth out the edge a bit.img_x = ndimage.convolve(img_gray.astype('float'), Fx, mode='nearest')img_y = ndimage.convolve(img_gray.astype('float'), Fy, mode='nearest')pylab.gray()pylab.subplot(1, 3, 1)pylab.imshow(img_gray.astype('float'))pylab.subplot(1, 3, 2)pylab.imshow(img_x)pylab.jet()pylab.subplot(1, 3, 3)pylab.imshow(img_y)pylab.colorbar()if(VIEW):    pyplot.show()#If you look at [X=232,Y=434] you'll see an example of an edge (a transition from bright to dark (or vice versa).#In the middle image we see the edges along X as bright red, and in the right-most image we see edges along Y.    #Now let's import some built in filters to see their results#Import some built-in filtersfrom skimage import filters#By smoothing the image before detecting edges we look for wider and wider edgesimg_graySmooth = filters.gaussian(img_gray,sigma=4)img_x = ndimage.convolve(img_graySmooth, Fx, mode='nearest')img_y = ndimage.convolve(img_graySmooth, Fy, mode='nearest')pylab.gray()pylab.subplot(1, 3 ,1)pylab.imshow(img)pylab.subplot(1, 3, 2)pylab.imshow(img_x)pylab.jet()pylab.subplot(1, 3, 3)pylab.imshow(img_y)pylab.colorbar()if(VIEW):    pyplot.show()#Finally, let's compute the gradient magnitude. This is the strength of an edge at each pixel,#that combines both the x and y. It is the length of the vector    gradientMagnitude = np.sqrt(np.square(img_x) + np.square(img_y))pylab.subplot(1, 2, 1)pylab.imshow(img)pylab.subplot(1, 2, 2)pylab.imshow(gradientMagnitude)if(VIEW):    pyplot.show()