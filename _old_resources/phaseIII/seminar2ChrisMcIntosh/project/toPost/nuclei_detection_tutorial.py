import numpy as npimport pylabimport sysfrom skimage import iofrom skimage import colorfrom scipy import ndimagefrom skimage.feature import match_templatefrom skimage.feature import peak_local_maxfrom matplotlib import pyplotimport project_helpers as ph# Flag that indicates whether to show images.# When True you will need to close each window after you've looked at the output to continueVIEW = False# Set the path to the data files.data_path = "crchistophenotypes_2016_04_28/CRCHistoPhenotypes_2016_04_28/"#################Nucleus detection - Template matching Tutorial#################img, detections, labels = ph.load_data_set(data_path,"img7")#Click the pan-axis button, and pan while holding left mouse; zoom while holding right#Find the boundary box of a template cell, or use the one belowpyplot.imshow(img)pyplot.autoscale(False)pyplot.plot(detections[:, 0], detections[:, 1], 'kx')if(VIEW):    pyplot.show()#Create the template nucleus using your own bounding-box co-ordinates, or the ones I pickedimg_gray = color.rgb2gray(img)T = img_gray[255:265,178:192]pylab.imshow(T)if(VIEW):    pyplot.show()#Use template matching, which is very similar to convolution#to find out where the template appears in the image.#The intensity of each pixel represents how well the template matches to that locationmatch = match_template(img_gray, T, pad_input=True)pylab.imshow(match)if(VIEW):    pyplot.show()#Use non-maximal supression to find  local maxima (peaks) in the output that#indicate the strongest response to our template in a local area. We expect#these to be the centroids of the nucleicoordinates = peak_local_max(match, min_distance=20)coordinates = np.fliplr(coordinates) #Flip the results to plot(x,y) from matrix (row,column)###################TODO 3.0 finish the score_detector function to score the results in project_helpers.py###################precision, recall, F1Measure, FNList = ph.score_detector(detections, coordinates)#You can display your results using the provided display_detection_results helper#The predicted locations will be green points#X's indicate the ground truth nuclei.#false negatives (i.e. missed nuclei) are red Xs#True positives are black Xs.#False negatives are green circles without a nearby black X.#There are a lot of false positives (green circles without a nearby black X)!ph.display_detection_results(img, detections, coordinates, FNList, VIEW)#################Nucleus detection - Features and Machine learning##################Load the image and the nuclei dataimg, detections, labels = ph.load_data_set(data_path,"img7")#Get the same template used earlierimg_gray = ph.my_rgb2gray(img)T = img_gray[255:265, 178:192]################PART 3.1 - Following the tutorial to train your first nuclei detector!################Todo 3.1 - fill in calculate_features in project_helpers.pyfeaturesND = ph.calculate_features(img,T)#Get some training samples:# matched pairs of image features at a pixel, and a binary label for nuclei centre (1) or not (0)N = 15000features_train, labels_train = ph.get_training_samples(featuresND, detections, img_gray, N)#Train a classifier using decision forests to predict the labels (center or not) from the features     classif_oneTemplate, scaler_oneTemplate = ph.train_model(features_train, labels_train)#Predict the output for all of the featuresprobability_prediction, predictions = ph.predict_centres(img_gray, featuresND, scaler_oneTemplate, classif_oneTemplate)#Display the resulting probability distribution showing where it thinks centres are#Bright spots indicate where centres are predictedpyplot.imshow(probability_prediction)if(VIEW):    pyplot.show()#Score the new results and compare to those in part 3.0; A huge jump in true positives!precision, recall, F1Measure, FNList = ph.score_detector(detections, predictions)ph.display_detection_results(img, detections, predictions, FNList,VIEW)###################PART 3.2 - What about the nuclei that look different from our template?###################TODO 3.2 - Fill in the get_templates function in project_helpers to get an entire set of templates! One for each type of celltemplates = ph.get_templates(img_gray, detections, 25)#Visualize the set of templates using the provided helper functionph.display_templates(templates, VIEW)#Train a model as before, but using the new featuresfeaturesND = ph.calculate_features(img, templates)features_train,labels_train = ph.get_training_samples(featuresND, detections, img_gray, N)classif_multipleTemplates, scaler_multipleTemplates = ph.train_model(features_train, labels_train)        #Predict the outputprobability_prediction, predictionsNew = ph.predict_centres(img_gray, featuresND, scaler_multipleTemplates, classif_multipleTemplates)#Score the old resultsprecision, recall, F1Measure, FNList = ph.score_detector(detections, predictions)#Score the new results - Very simlar results...precision, recall, F1Measure, FNList = ph.score_detector(detections, predictionsNew)#############Part 3.3 - So far we've only tested on the same image we are using for training, that is biased. It's like using the real exam for a practice test!#Let's test a novel image##############Load a new imageimgB, detectionsB, labelsB = ph.load_data_set(data_path,"img84")#This image looks very different.#TODO 3.3.1 - Can you spot the cells? Don't cheat :Dpyplot.imshow(imgB)if(VIEW):    pyplot.show()#Let's see the answerpyplot.imshow(imgB)pyplot.autoscale(False)pyplot.plot(detectionsB[:, 0], detectionsB[:, 1], 'kx')if(VIEW):    pyplot.show()#TODO 3.3.1 Fill out and use the validate_image function project_helpers.py to help you    #TODO 3.3.2- Get the features, run the prediction, and score the result for the new image for both#classif_oneTemplate and classif_multipleTemplates. Follow the examples above.# Use ph.display_detection_results(imgB, detectionsB, predictionsB, FNList, VIEW) to visualize your results# Compare the two models# This image looks very different and so our templates won't match very well#BEGIN TODO 3.3 HEREprint('Warning, 3.3.2 missing here')#END TODO 3.3 HERE##################Part 3.4 - We are on the right track, but we want to simulate your medical training. You don't just look at one image, you see many!##################Setup the same experiment but train on the first N images with K templates per image#I suggest the following values:max_template_count = 10img_count = 23N = 3500 * img_counttemplate_img_count = 15#First get all of the templatestemplate_set = ph.get_template_set(data_path, template_img_count, max_template_count)#TODO 3.4 - Fill out get_features_for_image_set# Get all of the features for the training imagesfeatures_train,labels_train = ph.get_features_for_image_set(data_path, img_count, N, template_set)#Visualize our new templatesph.display_templates(template_set, VIEW)#This will take a while, time for a coffeeclassif,scaler = ph.train_model(features_train, labels_train)#TODO 3.4.1 - Get the features, run the prediction, and score the result for the new image using validate_image#Score and display yours results#BEGIN TODO 3.4.2 HEREprint('Warning, 3.4.2 missing here')#END TODO 3.4.2 HEREprint('If there are no warnings the tutorial is completed')