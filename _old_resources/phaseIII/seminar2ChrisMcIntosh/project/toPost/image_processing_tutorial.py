import numpy as npimport pylabimport sysfrom skimage import iofrom skimage import colorfrom scipy import ndimagefrom matplotlib import pyplotimport project_helpers as phfrom sklearn.multiclass import OneVsRestClassifierfrom sklearn.svm import SVCfrom sklearn import svmfrom sklearn.preprocessing import LabelBinarizerfrom sklearn.ensemble import RandomForestClassifier############## This tutorial walks through various functions used for the project# and some of the concepts covered in lecture.############### Flag that indicates whether to show images.VIEW = False# Set the path to the data files.data_path = "crchistophenotypes_2016_04_28/CRCHistoPhenotypes_2016_04_28/"##############Basic image I/O###############Load the ground truth labels#Detections are stored as [x,y] and labels are positive for detected nuclei centresimg, detections, labels = ph.load_data_set(data_path,"img7")pylab.imshow(img)if(VIEW):    pyplot.show()#Examine a value in the image array, why are there three numbers?#Images in python are stored [Y,X]. So this is (y=1,x=5)img[1,5]#Display only the red channelpylab.imshow(img[:,:,0])if(VIEW):    pyplot.show()#Show the image with detectionspyplot.imshow(img)pyplot.autoscale(False)pyplot.plot(detections[:, 0], detections[:, 1], 'kx')if(VIEW):    pyplot.show()#################Filtering: Lowest level vision##################Build a 3x3 averaging filterF = (1 / 9) * np.array([[1, 1, 1],[1, 1, 1],[1, 1, 1]])#Perform convolution and compareimgSmooth = ndimage.convolve(img[:,:,0].astype('float'), F, mode='constant', cval=0.0)#Perform repeated convolutionimgManySmooth = ndimage.convolve(img[:,:,0].astype('float'), F, mode='constant', cval=0.0)for a in range(1,20):    imgManySmooth = ndimage.convolve(imgManySmooth, F, mode='constant', cval=0.0)pylab.subplot(1, 3, 1)pylab.imshow(img[:, :, 0].astype('float'))pylab.subplot(1, 3, 2)pylab.imshow(imgSmooth)pylab.subplot(1, 3, 3)pylab.imshow(imgManySmooth)pylab.gray()if(VIEW):    pyplot.show()#Basic edge detectionFx = np.array([[1, 0, -1]])Fy = Fx.transpose() #use a different boundary conditionimg_x = ndimage.convolve(img[:,:,0].astype('float'), Fx, mode='nearest')img_y = ndimage.convolve(img[:,:,0].astype('float'), Fy, mode='nearest')pylab.gray()pylab.subplot(1, 3, 1)pylab.imshow(img[:,:,0].astype('float'))pylab.subplot(1, 3, 2)pylab.imshow(img_x)pylab.jet()pylab.subplot(1, 3, 3)pylab.imshow(img_y)pylab.colorbar()if(VIEW):    pyplot.show()#Putting them together#First make a grayscale copy of the imageimg_gray = color.rgb2gray(img)#Import some built-in filtersfrom skimage import filters#Increasing the scale increases the width of the detected edgesimg_graySmooth = filters.gaussian(img_gray,sigma=4)img_x = ndimage.convolve(img_graySmooth, Fx, mode='nearest')img_y = ndimage.convolve(img_graySmooth, Fy, mode='nearest')pylab.gray()pylab.subplot(1, 3 ,1)pylab.imshow(img[:,:,1].astype('float'))pylab.subplot(1, 3, 2)pylab.imshow(img_x)pylab.jet()pylab.subplot(1, 3, 3)pylab.imshow(img_y)pylab.colorbar()if(VIEW):    pyplot.show()#Compute the gradient magnitudegradientMagnitude = np.sqrt(np.square(img_x) + np.square(img_y))pylab.subplot(1, 2, 1)pylab.imshow(img)pylab.subplot(1, 2, 2)pylab.imshow(gradientMagnitude)if(VIEW):    pyplot.show()#################Nucleus detection - Template matching##################Click the pan-axis button, and pan while holding left mouse; zoom while holding right#Find the boundary box of a template cell, or use the one belowpyplot.imshow(img)pyplot.autoscale(False)pyplot.plot(detections[:, 0], detections[:, 1], 'kx')if(VIEW):    pyplot.show()#Create the template nucleusT = img_gray[255:265,178:192]pylab.imshow(T)if(VIEW):    pyplot.show()#Use template matching, which is very similar to convolution#to find out where the template appears in the image.from skimage.feature import match_templatematch = match_template(img_gray, T, pad_input=True)pylab.imshow(match)if(VIEW):    pyplot.show()#Use non-maximal supression to find peaks in the output that#indicate our template had a strong match at that positionfrom skimage.feature import peak_local_maxcoordinates = peak_local_max(match, min_distance=20)coordinates = np.fliplr(coordinates) #Flip the results to plot(x,y) from matrix (row,column)#TODO 2.1 finish the score_detector function to score the resultsprecision, recall, F1Measure, FNList = ph.score_detector(detections, coordinates)#Display the results- There are a lot of false negatives!ph.display_detection_results(img, detections, coordinates, FNList, VIEW)